<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three-Link Planar Arm Statics</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f9;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            display: flex;
            width: 100%;
            max-width: 1200px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .controls {
            width: 30%;
            padding: 20px;
            background: #2c3e50;
            color: #ecf0f1;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .results {
            width: 70%;
            padding: 20px;
        }
        #plot {
            background-color: #ffffff;
            border-radius: 8px;
            /* box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); */
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #2980b9;
        }
        .results h2 {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-weight: bold;
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
        }
        .results p {
            margin: 10px 0;
            font-size: 16px;
        }
        .results strong {
            color: #3498db;
        }
        svg {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>

<div class="container">
    <div class="controls">
        <h2>Controls</h2>
        <div class="control-group">
            <label>Link 1 Length (m): <span id="l1Value">0.3</span></label>
            <input type="range" id="l1" min="0.1" max="0.6" step="0.01" value="0.3">
        </div>
        <div class="control-group">
            <label>Link 2 Length (m): <span id="l2Value">0.35</span></label>
            <input type="range" id="l2" min="0.1" max="0.6" step="0.01" value="0.35">
        </div>
        <div class="control-group">
            <label>Link 3 Length (m): <span id="l3Value">0.2</span></label>
            <input type="range" id="l3" min="0.05" max="0.6" step="0.01" value="0.2">
        </div>
        <div class="control-group">
            <label>Joint Angle 1 (deg): <span id="theta1Value">0</span></label>
            <input type="range" id="theta1" min="0" max="180" step="0.1" value="0">
        </div>
        <div class="control-group">
            <label>Joint Angle 2 (deg): <span id="theta2Value">0</span></label>
            <input type="range" id="theta2" min="0" max="180" step="0.1" value="90">
        </div>
        <div class="control-group">
            <label>Joint Angle 3 (deg): <span id="theta3Value">0</span></label>
            <input type="range" id="theta3" min="-90" max="90" step="0.1" value="45">
        </div>
        <div class="control-group">
            <label>Joint Torque 1 (deg): <span id="torque1Value">0</span></label>
            <input type="range" id="torque1" min="-3" max="3" step="0.01" value="0">
        </div>
        <div class="control-group">
            <label>Joint Torque 2 (deg): <span id="torque2Value">0</span></label>
            <input type="range" id="torque2" min="-3" max="3" step="0.01" value="0">
        </div>
        <div class="control-group">
            <label>Joint Torque 3 (deg): <span id="torque3Value">0</span></label>
            <input type="range" id="torque3" min="-3" max="3" step="0.01" value="0">
        </div>
        <button id="resetButton">Reset Values</button>
    </div>

    <div class="results">
        <h2>Three Link Arm Visualization</h2>
        <svg id="plot" width="500" height="500">
            <line x1="0" y1="250" x2="500" y2="250" stroke="black"/> <!-- X-axis -->
            <line x1="250" y1="0" x2="250" y2="500" stroke="black"/> <!-- Y-axis -->
        </svg>
        <p><strong>Endpoint Position (m):</strong>
            [<span id="xPos">0.00</span>,
            <span id="yPos">0.00</span>]
        </p>
        <p><strong>Endpoint Force (N): </strong>
            [<span id="epforcex">0.00</span>, 
            <span id="epforcey">0.00</span>]
        </p>
        <p><strong>Endpoint Moment (Nm): </strong>
            <span id="epmoment">0.00</span>
        </p>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.1/math.min.js"></script>
<script>
    // Page level constants
    const lengthToPixelScale = 300;
    const svg = d3.select("#plot");
    const width = +svg.attr("width");
    const height = +svg.attr("height");
    const origin = {x: width/2, y: 3 * height/4};

    // Update slider values
    document.querySelectorAll('input[type="range"]').forEach(input => {
        const id = input.id;
        const value = document.getElementById(id + 'Value');
        input.addEventListener('input', () => {
            value.innerText = input.value;
        });
    });

    // Reset sliders.
    document.getElementById('resetButton').addEventListener('click', () => {
        const defaults = {
            l1: 0.3, l2: 0.35, l3: 0.2,
            theta1: 0, theta2: 90, theta3: 45,
            torque1: 0, torque2: 0, torque3: 0
        };

        for (const key in defaults) {
            const slider = document.getElementById(key);
            slider.value = defaults[key];
            document.getElementById(key + 'Value').textContent = defaults[key];
            slider.dispatchEvent(new Event('input'));
        }
    });

    // Three link arm class.
    class ThreeLinkArm {
        #jacobian = math.zeros(3, 3);

        constructor(lengths, angles) {
            this.lengths = lengths;
            this.angles = angles;
            this.#updateJacobian();
        }
    
        setAngles(newAngles) {
            this.angles = newAngles;
            this.#updateJacobian();
        }

        setLengths(newLengths) {
            this.lengths = newLengths;
            this.#updateJacobian();
        }
    
        #updateJacobian() {
            const _sterms = cummulativeSum(this.angles).map(angle => Math.sin(angle));
            const _cterms = cummulativeSum(this.angles).map(angle => Math.cos(angle));
            this.#jacobian.set([0, 0], -this.lengths[0] * _sterms[0] - this.lengths[1] * _sterms[1] - this.lengths[2] * _sterms[2]);
            this.#jacobian.set([0, 1], -this.lengths[1] * _sterms[1] - this.lengths[2] * _sterms[2]);
            this.#jacobian.set([0, 2], -this.lengths[2] * _sterms[2]);
            this.#jacobian.set([1, 0], this.lengths[0] * _cterms[0] + this.lengths[1] * _cterms[1] + this.lengths[2] * _cterms[2]);
            this.#jacobian.set([1, 1], this.lengths[1] * _cterms[1] + this.lengths[2] * _cterms[2]);
            this.#jacobian.set([1, 2], this.lengths[2] * _cterms[2]);
            this.#jacobian.set([2, 0], 1);
            this.#jacobian.set([2, 1], 1);
            this.#jacobian.set([2, 2], 1);
        }

        getJacobian() {
            return this.#jacobian;
        }

        getArmPositions() {
            const cusumtheta = cummulativeSum(this.angles);
            const x1 = 0, y1 = 0;
            const x2 = this.lengths[0] * Math.cos(cusumtheta[0]);
            const y2 = this.lengths[0] * Math.sin(cusumtheta[0]);
            const x3 = x2 + this.lengths[1] * Math.cos(cusumtheta[1]);
            const y3 = y2 + this.lengths[1] * Math.sin(cusumtheta[1]);
            const x4 = x3 + this.lengths[2] * Math.cos(cusumtheta[2]);
            const y4 = y3 + this.lengths[2] * Math.sin(cusumtheta[2]);
            return [[x1, y1], [x2, y2], [x3, y3], [x4, y4]];
        }

        forwardStatics(torque) {
            try {
                const pinvJ = math.pinv(math.transpose(this.getJacobian()));
                return math.multiply(pinvJ, math.reshape(torque, [-1, 1])).toArray().flat();
            } catch (error) {
                return null;
            }
        }
    }

    // Useful Functions
    function mapPositionsToCoordinates(positions, origin) {
        return positions.map(pos => [origin.x + pos[0] * lengthToPixelScale,
                                    origin.y - pos[1] * lengthToPixelScale]);
    }

    function degreesToRadians(degreesArray) {
        return degreesArray.map(deg => deg * Math.PI / 180);
    }

    function cummulativeSum(array) {
        return array.reduce((acc, curr) => {
            acc.push(acc[acc.length - 1] + curr);
            return acc;
        }, [0]).slice(1);
    }

    function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        const angleInRadians = angleInDegrees;
        return {
            x: centerX + (radius * Math.cos(angleInRadians)),
            y: centerY - (radius * Math.sin(angleInRadians))
        };
    }

    function describeArc(x, y, radius, startAngle, endAngle) {
        const start = polarToCartesian(x, y, radius, startAngle);
        const end = polarToCartesian(x, y, radius, endAngle);
        const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
        const sweetDir = endAngle - startAngle >= 0 ? "0" : "1";
        return `
            M ${start.x} ${start.y}
            A ${radius} ${radius} 0 ${largeArcFlag} ${sweetDir} ${end.x} ${end.y}
        `;
    }
    // End of useful functions

    // Other plotting related functions.
    function getJoinTorqueArcInfo(angle, torque, scale=0.25) {
        const taustrtang = angle;
        const tauendang = angle + torque * Math.PI * scale;
        return [taustrtang, tauendang];
    }
    // End of other plotting related functions.

    function updateArm() {
        // Get new lengths and angles
        const lengths = [
            +document.getElementById('l1').value,
            +document.getElementById('l2').value,
            +document.getElementById('l3').value
        ];

        const theta = [
            +document.getElementById('theta1').value,
            +document.getElementById('theta2').value,
            +document.getElementById('theta3').value
        ];

        const torque = [
            +document.getElementById('torque1').value,
            +document.getElementById('torque2').value,
            +document.getElementById('torque3').value
        ]

        // Convert to radians
        const thetar = degreesToRadians(theta);

        // Update arm lengths and angles
        arm.setLengths(lengths);
        arm.setAngles(thetar);

        // Update visualization
        const armpos = arm.getArmPositions();
        const epforce = arm.forwardStatics(torque);
        // Endpot force components
        const epforcecomps = [
            arm.forwardStatics([torque[0], 0, 0]),
            arm.forwardStatics([0, torque[1], 0]),
            arm.forwardStatics([0, 0, torque[2]])
        ];
        updateArmVisualization(arm.angles, armpos, origin, torque, epforce, epforcecomps);

        // Update end-effector position
        document.getElementById('xPos').innerText = armpos[3][0].toFixed(2);
        document.getElementById('yPos').innerText = armpos[3][1].toFixed(2);

        // End point force calculation
        document.getElementById('epforcex').innerText = epforce[0].toFixed(2);
        document.getElementById('epforcey').innerText = epforce[1].toFixed(2);
        document.getElementById('epmoment').innerText = epforce[2].toFixed(2);
    }

    function updateArmVisualization(angles, armpos, origin, torque, epforce, epforcecomps) {
        svg.selectAll("line").remove();
        svg.selectAll("circle").remove();
        svg.selectAll("path").remove();

        // Add the x and y axis.
        svg.append("line").attr("x1", 0).attr("y1", origin.y)
        .attr("x2", width).attr("y2", origin.y).attr("stroke", "lightgray").attr("stroke-width", 0.5);
        svg.append("line").attr("x1", origin.x).attr("y1", 0)
        .attr("x2", origin.x).attr("y2", height).attr("stroke", "lightgray").attr("stroke-width", 0.5);
        
        // Map arm positions to x and y coordinates
        armpos = mapPositionsToCoordinates(armpos, origin);

        // Draw links
        for (let i = 0; i < armpos.length - 1; i++) {
            svg.append("line")
                .attr("x1", armpos[i][0])
                .attr("y1", armpos[i][1])
                .attr("x2", armpos[i+1][0])
                .attr("y2", armpos[i+1][1])
                .attr("stroke", "#8888ff")
                .attr("stroke-width", 3);
        }

        // Draw joints
        armpos.slice(0, -1).forEach(pos => {
            svg.append("circle")
                .attr("cx", pos[0])
                .attr("cy", pos[1])
                .attr("r", 3)
                .attr("stroke", "#8888ff")
                .attr("fill", "#ffffff");
        });

        // Draw the torque arcs around joints.
        const cusumangles = cummulativeSum(angles);
        const torqArcAngles = cusumangles.map((angle, i) => getJoinTorqueArcInfo(angle, torque[i]));
        const compcolors = ["black", "violet", "brown"]
        torqArcAngles.forEach((angles, i) => {
            const arcPath = describeArc(armpos[i][0], armpos[i][1], 20, angles[0], angles[1]);
            svg.append("path")
                .attr("d", arcPath)
                .attr("stroke", compcolors[i])
                .attr("fill", "none")
                .attr("stroke-width", 1.5);
        });

        // Endpoint force.
        if (epforce) {
            // Draw an arrow to represent the force.
            const forceEnd = [armpos[3][0] - epforce[0] * lengthToPixelScale * 0.025,
                              armpos[3][1] + epforce[1] * lengthToPixelScale * 0.025];
            // Don't draw the arrow if the force is too small
            if (math.norm(epforce) > 0.05) {
                // Define the arrow marker
                svg.append("defs").append("marker")
                    .attr("id", "arrow")
                    .attr("viewBox", "0 0 10 10")
                    .attr("refX", 9)
                    .attr("refY", 5)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto-start-reverse")
                    .append("path")
                    .attr("d", "M 0 0 L 10 5 L 0 10 z")
                    .attr("fill", "red")
                    .attr("stroke", "red");

                // Draw the line with the arrow
                svg.append("line")
                    .attr("x1", armpos[3][0])
                    .attr("y1", armpos[3][1])
                    .attr("x2", forceEnd[0])
                    .attr("y2", forceEnd[1])
                    .attr("fill", "red")
                    .attr("stroke", "red")
                    .attr("marker-end", "url(#arrow)")
                    .attr("stroke-width", 1.5);
            }

            // Let's draw the force components with thinner and lighter arrows.
            // Component 1
            const _force1 = [armpos[3][0] - epforcecomps[0][0] * lengthToPixelScale * 0.025,
                             armpos[3][1] + epforcecomps[0][1] * lengthToPixelScale * 0.025];
            // Do the above computation for all components.
            const _fcomps = epforcecomps.map((fcomp) => [
                armpos[3][0] - fcomp[0] * lengthToPixelScale * 0.025,
                armpos[3][1] + fcomp[1] * lengthToPixelScale * 0.025
            ]);
            _fcomps.forEach((_fc, i) => {
                if (math.norm(epforce) > 0.05 && math.norm(_fc) > 0.05) {
                    // Define the arrow marker
                    svg.append("defs").append("marker")
                        .attr("id", "arrow")
                        .attr("viewBox", "0 0 10 10")
                        .attr("refX", 9)
                        .attr("refY", 5)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto-start-reverse")
                        .append("path")
                        .attr("d", "M 0 0 L 10 5 L 0 10 z")
                        .attr("fill", compcolors[i])
                        .attr("stroke", compcolors[i]);

                    // Draw the line with the arrow
                    svg.append("line")
                        .attr("x1", armpos[3][0])
                        .attr("y1", armpos[3][1])
                        .attr("x2", _fc[0])
                        .attr("y2", _fc[1])
                        .attr("fill", compcolors[i])
                        .attr("stroke", compcolors[i])
                        .attr("marker-end", "url(#arrow)")
                        .attr("stroke-width", 1);
                }
            });
            
            // Draw the arc for the endpoint moment (epforce[2])
            const torqArcAngle = getJoinTorqueArcInfo(math.sum(angles), epforce[2] / 2);
            const arcPath = describeArc(armpos[3][0], armpos[3][1], 15, torqArcAngle[0] - Math.PI, torqArcAngle[1] - Math.PI);
            svg.append("path")
                .attr("d", arcPath)
                .attr("stroke", "green")
                .attr("fill", "none")
                .attr("stroke-width", 1.5);
        }
    }

    // Create the arm object once and reuse it
    const arm = new ThreeLinkArm(
        [1, 1, 1], // Initial lengths
        degreesToRadians([0, 0, 0]) // Initial angles
    );

    // Attach event listeners to sliders
    ['l1', 'l2', 'l3', 'theta1', 'theta2', 'theta3', 'torque1', 'torque2', 'torque3'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateArm);
    });

    // Initialize the arm visualization
    updateArm();
</script>

</body>
</html>