<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Link Planar Arm Statics</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f9;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            display: flex;
            width: 100%;
            max-width: 1200px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .controls {
            width: 30%;
            padding: 20px;
            background: #2c3e50;
            color: #ecf0f1;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .results {
            width: 70%;
            padding: 20px;
        }
        #plot {
            background-color: #ffffff;
            border-radius: 8px;
            /* box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); */
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #2980b9;
        }
        .results h2 {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-weight: bold;
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
        }
        .results p {
            margin: 10px 0;
            font-size: 16px;
        }
        .results strong {
            color: #3498db;
        }
        svg {
            display: block;
            margin: 0 auto;
        }
        .plots-container {
            display: flex;
            gap: 20px; /* Space between the FBDs and the main plot */
            align-items: flex-start; /* Align items at the top */
        }
        .fbd-container {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Space between the two FBDs */
        }

        #fbd-link1, #fbd-link2 {
            border: 1px solid #ccc; /* Border for the FBDs */
            background-color: #f9f9f9; /* Light background */
            border-radius: 8px; /* Rounded corners */
        }
        footer {
            position: fixed; /* Fix the footer to the bottom of the viewport */
            bottom: 10px; /* Distance from the bottom */
            right: 10px; /* Distance from the right */
            font-family: 'Roboto', sans-serif; /* Use Roboto or a system font */
            font-size: 12px; /* Small font size */
            color: #666; /* Subtle gray color */
            /* background-color: rgba(255, 255, 255, 0.8); */
            padding: 5px 10px; /* Add some padding */
            border-radius: 5px; /* Rounded corners */
            /* box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); */
        }
    </style>
</head>
<body>

<div class="container">
    <div class="controls">
        <h2>Controls</h2>
        <div class="control-group">
            <label>Link 1 Length (m): <span id="l1Value">0.3</span></label>
            <input type="range" id="l1" min="0.1" max="0.6" step="0.01" value="0.3">
        </div>
        <div class="control-group">
            <label>Link 2 Length (m): <span id="l2Value">0.35</span></label>
            <input type="range" id="l2" min="0.1" max="0.6" step="0.01" value="0.35">
        </div>
        <div class="control-group">
            <label>Joint Angle 1 (deg): <span id="theta1Value">0</span></label>
            <input type="range" id="theta1" min="0" max="180" step="0.1" value="0">
        </div>
        <div class="control-group">
            <label>Joint Angle 2 (deg): <span id="theta2Value">0</span></label>
            <input type="range" id="theta2" min="0" max="180" step="0.1" value="90">
        </div>
        <div class="control-group">
            <label>Joint Torque 1 (deg): <span id="torque1Value">0</span></label>
            <input type="range" id="torque1" min="-3" max="3" step="0.01" value="0">
        </div>
        <div class="control-group">
            <label>Joint Torque 2 (deg): <span id="torque2Value">0</span></label>
            <input type="range" id="torque2" min="-3" max="3" step="0.01" value="0">
        </div>
        <button id="resetButton">Reset Values</button>
    </div>

    <div class="results">
        <h2>Two Link Arm Visualization</h2>
        <div class="plots-container">
            <!-- Free Body Diagrams -->
            <div class="fbd-container">
                <svg id="fbd-link1" width="200" height="200"></svg>
                <svg id="fbd-link2" width="200" height="200"></svg>
            </div>
            <!-- Main Plot -->
            <svg id="plot" width="500" height="500">
                <line x1="0" y1="250" x2="500" y2="250" stroke="black"/> <!-- X-axis -->
                <line x1="250" y1="0" x2="250" y2="500" stroke="black"/> <!-- Y-axis -->
            </svg>
        </div>
        <p><strong>Endpoint Position (m):</strong>
            [<span id="xPos">0.00</span>,
            <span id="yPos">0.00</span>]
        </p>
        <p><strong>Endpoint Force (N): </strong>
            [<span id="epforcex">0.00</span>, 
            <span id="epforcey">0.00</span>]
        </p>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.1/math.min.js"></script>
<script>
    // Page level constants
    const lengthToPixelScale = 300;
    const svgmain = d3.select("#plot");
    const svglink1 = d3.select("#fbd-link1");
    const svglink2 = d3.select("#fbd-link2");
    const width = +svgmain.attr("width");
    const height = +svgmain.attr("height");
    const origin = {x: width/2, y: 3 * height/4};
    const EPFORCECOLOR = "black";
    const COMPCOLORS = ["magenta", "brown"]

    // Update slider values
    document.querySelectorAll('input[type="range"]').forEach(input => {
        const id = input.id;
        const value = document.getElementById(id + 'Value');
        input.addEventListener('input', () => {
            value.innerText = input.value;
        });
    });

    // Reset sliders.
    document.getElementById('resetButton').addEventListener('click', () => {
        const defaults = {
            l1: 0.3, l2: 0.35,
            theta1: 0, theta2: 90,
            torque1: 0, torque2: 0
        };

        for (const key in defaults) {
            const slider = document.getElementById(key);
            slider.value = defaults[key];
            document.getElementById(key + 'Value').textContent = defaults[key];
            slider.dispatchEvent(new Event('input'));
        }
    });

    // Three link arm class.
    class TwoLinkArm {
        #jacobian = math.zeros(2, 2);
        #armpos  = [[0, 0], [0, 0], [0, 0]];

        constructor(lengths, angles) {
            this.lengths = lengths;
            this.angles = angles;
            this.#updateJacobian();
        }
    
        setAngles(newAngles) {
            this.angles = newAngles;
            this.#updateArmPosition();
            this.#updateJacobian();
        }
        
        setLengths(newLengths) {
            this.lengths = newLengths;
            this.#updateArmPosition();
            this.#updateJacobian();
        }

        getArmPosition() {
            return this.#armpos;
        }

        #updateArmPosition() {
            const cusumtheta = cummulativeSum(this.angles);
            this.#armpos[1][0] = this.lengths[0] * Math.cos(cusumtheta[0]);
            this.#armpos[1][1] = this.lengths[0] * Math.sin(cusumtheta[0]);
            this.#armpos[2][0] = this.#armpos[1][0] + this.lengths[1] * Math.cos(cusumtheta[1]);
            this.#armpos[2][1] = this.#armpos[1][1] + this.lengths[1] * Math.sin(cusumtheta[1]);
        }
    
        #updateJacobian() {
            const _sterms = cummulativeSum(this.angles).map(angle => Math.sin(angle));
            const _cterms = cummulativeSum(this.angles).map(angle => Math.cos(angle));
            this.#jacobian.set([0, 0], -this.lengths[0] * _sterms[0] - this.lengths[1] * _sterms[1]);
            this.#jacobian.set([0, 1], -this.lengths[1] * _sterms[1]);
            this.#jacobian.set([1, 0], this.lengths[0] * _cterms[0] + this.lengths[1] * _cterms[1]);
            this.#jacobian.set([1, 1], this.lengths[1] * _cterms[1]);
        }

        getJacobian() {
            return this.#jacobian;
        }

        forwardStatics(torque) {
            try {
                const pinvJ = math.pinv(math.transpose(this.getJacobian()));
                return math.multiply(pinvJ, math.reshape(torque, [-1, 1])).toArray().flat();
            } catch (error) {
                return null;
            }
        }

        link1FreeBodyForceMoments(torque) {
            // End point force.
            const epforce = this.forwardStatics(torque);
            return {
                proximal: {
                    angle: this.angles[0],
                    position: this.#armpos[0],
                    forces: [[-epforce[0], -epforce[1]]],
                    torque: torque[0]
                },
                distal: {
                    angle: this.angles[0] + Math.PI,
                    position: this.#armpos[1],
                    forces: [epforce],
                    torque: -torque[1]
                }
            }
        }

        link2FreeBodyForceMoments(torque) {
            // End point force.
            const epforce = this.forwardStatics(torque);
            return {
                proximal: {
                    angle: math.sum(this.angles),
                    position: this.#armpos[1],
                    forces: [[-epforce[0], -epforce[1]]],
                    torque: torque[1]
                },
                distal: {
                    angle: math.sum(this.angles) + Math.PI,
                    position: this.#armpos[2],
                    forces: [epforce],
                    torque: 0
                }
            }
        }
    }

    // Useful Functions
    function mapPositionsToCoordinates(positions, origin, scale=250) {
        return positions.map(pos => [origin.x + pos[0] * scale,
                                     origin.y - pos[1] * scale]);
    }

    function degreesToRadians(degreesArray) {
        return degreesArray.map(deg => deg * Math.PI / 180);
    }

    function cummulativeSum(array) {
        return array.reduce((acc, curr) => {
            acc.push(acc[acc.length - 1] + curr);
            return acc;
        }, [0]).slice(1);
    }

    function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        const angleInRadians = angleInDegrees;
        return {
            x: centerX + (radius * Math.cos(angleInRadians)),
            y: centerY - (radius * Math.sin(angleInRadians))
        };
    }

    function describeArc(x, y, radius, startAngle, endAngle) {
        const start = polarToCartesian(x, y, radius, startAngle);
        const end = polarToCartesian(x, y, radius, endAngle);
        const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
        const sweetDir = endAngle - startAngle >= 0 ? "0" : "1";
        return `
            M ${start.x} ${start.y}
            A ${radius} ${radius} 0 ${largeArcFlag} ${sweetDir} ${end.x} ${end.y}
        `;
    }
    // End of useful functions

    // Other plotting related functions.
    function getJoinTorqueArcInfo(angle, torque, scale=0.25) {
        const taustrtang = angle;
        const tauendang = angle + torque * Math.PI * scale;
        return [taustrtang, tauendang];
    }
    // End of other plotting related functions.

    // Update the arm when controls are changed.
    function updateArm() {
        // Get new lengths and angles
        const lengths = [
            +document.getElementById('l1').value,
            +document.getElementById('l2').value
        ];

        const theta = [
            +document.getElementById('theta1').value,
            +document.getElementById('theta2').value
        ];

        const torque = [
            +document.getElementById('torque1').value,
            +document.getElementById('torque2').value
        ]

        // Convert to radians
        const thetar = degreesToRadians(theta);

        // Update arm lengths and angles
        arm.setLengths(lengths);
        arm.setAngles(thetar);

        // Update visualization
        const armpos = arm.getArmPosition();
        const epforce = arm.forwardStatics(torque);
        // Endpot force components
        const epforcecomps = [
            arm.forwardStatics([torque[0], 0]),
            arm.forwardStatics([0, torque[1]])
        ];
        updateArmVisualization(arm.angles, armpos, origin, torque, epforce, epforcecomps);

        // Update end-effector position
        document.getElementById('xPos').innerText = armpos[1][0].toFixed(2);
        document.getElementById('yPos').innerText = armpos[1][1].toFixed(2);

        // End point force calculation
        document.getElementById('epforcex').innerText = epforce[0].toFixed(2);
        document.getElementById('epforcey').innerText = epforce[1].toFixed(2);

        // Free body diagram for link1
        visualizeFBDLink1(arm.link1FreeBodyForceMoments(torque));
        visualizeFBDLink2(arm.link2FreeBodyForceMoments(torque));
    }

    // Full arm visualization
    function updateArmVisualization(angles, armpos, origin, torque, epforce, epforcecomps) {
        svgmain.selectAll("line").remove();
        svgmain.selectAll("circle").remove();
        svgmain.selectAll("path").remove();

        // Add the x and y axis.
        svgmain.append("line").attr("x1", 0).attr("y1", origin.y)
        .attr("x2", width).attr("y2", origin.y).attr("stroke", "lightgray").attr("stroke-width", 0.5);
        svgmain.append("line").attr("x1", origin.x).attr("y1", 0)
        .attr("x2", origin.x).attr("y2", height).attr("stroke", "lightgray").attr("stroke-width", 0.5);
        
        // Map arm positions to x and y coordinates
        armpos = mapPositionsToCoordinates(armpos, origin);

        // Draw links
        for (let i = 0; i < armpos.length - 1; i++) {
            svgmain.append("line")
                .attr("x1", armpos[i][0])
                .attr("y1", armpos[i][1])
                .attr("x2", armpos[i+1][0])
                .attr("y2", armpos[i+1][1])
                .attr("stroke", "#8888ff")
                .attr("stroke-width", 3);
        }

        // Draw joints
        armpos.slice(0, -1).forEach(pos => {
            svgmain.append("circle")
                .attr("cx", pos[0])
                .attr("cy", pos[1])
                .attr("r", 3)
                .attr("stroke", "#8888ff")
                .attr("fill", "#ffffff");
        });

        // Draw the torque arcs around joints.
        const cusumangles = cummulativeSum(angles);
        const torqArcAngles = cusumangles.map((angle, i) => getJoinTorqueArcInfo(angle, torque[i]));
        torqArcAngles.forEach((angles, i) => {
            const arcPath = describeArc(armpos[i][0], armpos[i][1], 20, angles[0], angles[1]);
            svgmain.append("path")
                .attr("d", arcPath)
                .attr("stroke", COMPCOLORS[i])
                .attr("fill", "none")
                .attr("stroke-width", 1.5);
        });

        // Endpoint force.
        if (epforce) {
            // Main EP force arrow.
            plotForceArrow(svgmain, armpos[2], epforce, EPFORCECOLOR, 1.0);
            // EP force components.
            epforcecomps.forEach((_epfc, i) => {
                plotForceArrow(svgmain, armpos[2], _epfc, COMPCOLORS[i], 1.0);
            });
        }
    }

    // Visualize the free body diagram for link1.
    function visualizeFBDLink1(linkdetails) {
        svglink1.selectAll("line").remove();
        svglink1.selectAll("circle").remove();
        svglink1.selectAll("path").remove();

        // Map arm positions to x and y coordinates
        const width = +svglink1.attr("width");
        const height = +svglink1.attr("height");
        const origin = {x: width/2, y: height/2};
        const midlinkpos = [
            (linkdetails.distal.position[0] - linkdetails.proximal.position[0]) / 2,
            (linkdetails.distal.position[1] - linkdetails.proximal.position[1]) / 2
        ];
        const _proxshifted = [linkdetails.proximal.position[0] - midlinkpos[0],
                              linkdetails.proximal.position[1] - midlinkpos[1]];
        const _distshifted = [linkdetails.distal.position[0] - midlinkpos[0],
                              linkdetails.distal.position[1] - midlinkpos[1]];
        const _lpshiftedpos = mapPositionsToCoordinates(
            [_proxshifted, _distshifted],
            origin,
            scale=300
        );
        // Draw the link with the correct orientation
        svglink1.append("line")
            .attr("x1", _lpshiftedpos[0][0])
            .attr("y1", _lpshiftedpos[0][1])
            .attr("x2", _lpshiftedpos[1][0])
            .attr("y2", _lpshiftedpos[1][1])
            .attr("stroke", "#8888ff")
            .attr("stroke-width", 3);
        // Draw joints
        _lpshiftedpos.forEach(pos => {
            svglink1.append("circle")
                .attr("cx", pos[0])
                .attr("cy", pos[1])
                .attr("r", 3)
                .attr("stroke", "#8888ff")
                .attr("fill", "#ffffff");
        });

        // Draw the force due to the promimal joint torque
        plotForceArrow(svglink1, _lpshiftedpos[0], linkdetails.proximal.forces[0], EPFORCECOLOR, 1.0);
        // Draw the force due to the distal joint torque
        plotForceArrow(svglink1, _lpshiftedpos[1], linkdetails.distal.forces[0], EPFORCECOLOR, 1.0);

        // Draw the torque arcs around joints.
        // Proximal joint
        var _torqarc = getJoinTorqueArcInfo(linkdetails.proximal.angle, linkdetails.proximal.torque);
        var arcPath = describeArc(_lpshiftedpos[0][0], _lpshiftedpos[0][1], 20, _torqarc[0], _torqarc[1]);
        svglink1.append("path")
            .attr("d", arcPath)
            .attr("stroke", COMPCOLORS[0])
            .attr("fill", "none")
            .attr("stroke-width", 1.5);
        // Distal joint
        _torqarc = getJoinTorqueArcInfo(linkdetails.distal.angle, linkdetails.distal.torque);
        arcPath = describeArc(_lpshiftedpos[1][0], _lpshiftedpos[1][1], 20, _torqarc[0], _torqarc[1]);
        svglink1.append("path")
            .attr("d", arcPath)
            .attr("stroke", COMPCOLORS[1])
            .attr("fill", "none")
            .attr("stroke-width", 1.5);
    }

    // Visualize the free body diagram for link2.
    function visualizeFBDLink2(linkdetails) {
        svglink2.selectAll("line").remove();
        svglink2.selectAll("circle").remove();
        svglink2.selectAll("path").remove();

        // Map arm positions to x and y coordinates
        const width = +svglink2.attr("width");
        const height = +svglink2.attr("height");
        const origin = {x: width/2, y: height/2};
        const midlinkpos = [
            (linkdetails.distal.position[0] - linkdetails.proximal.position[0]) / 2,
            (linkdetails.distal.position[1] - linkdetails.proximal.position[1]) / 2
        ];
        const _proxshifted = [- midlinkpos[0], - midlinkpos[1]];
        const _distshifted = [linkdetails.distal.position[0] - linkdetails.proximal.position[0] - midlinkpos[0],
                              linkdetails.distal.position[1] - linkdetails.proximal.position[1]  - midlinkpos[1]];
        const _lpshiftedpos = mapPositionsToCoordinates(
            [_proxshifted, _distshifted],
            origin,
            scale=300
        );
        console.log(_lpshiftedpos);
        // Draw the link with the correct orientation
        svglink2.append("line")
            .attr("x1", _lpshiftedpos[0][0])
            .attr("y1", _lpshiftedpos[0][1])
            .attr("x2", _lpshiftedpos[1][0])
            .attr("y2", _lpshiftedpos[1][1])
            .attr("stroke", "#8888ff")
            .attr("stroke-width", 3);
        // Draw joints
        _lpshiftedpos.slice(0, 1).forEach(pos => {
            svglink2.append("circle")
                .attr("cx", pos[0])
                .attr("cy", pos[1])
                .attr("r", 3)
                .attr("stroke", "#8888ff")
                .attr("fill", "#ffffff");
        });

        // Draw the force due to the promimal joint torque
        plotForceArrow(svglink2, _lpshiftedpos[0], linkdetails.proximal.forces[0], EPFORCECOLOR, 1.0);
        // Draw the force due to the distal joint torque
        plotForceArrow(svglink2, _lpshiftedpos[1], linkdetails.distal.forces[0], EPFORCECOLOR, 1.0);

        // Draw the torque arcs around joints.
        // Proximal joint
        var _torqarc = getJoinTorqueArcInfo(linkdetails.proximal.angle, linkdetails.proximal.torque);
        var arcPath = describeArc(_lpshiftedpos[0][0], _lpshiftedpos[0][1], 20, _torqarc[0], _torqarc[1]);
        svglink2.append("path")
            .attr("d", arcPath)
            .attr("stroke", COMPCOLORS[1])
            .attr("fill", "none")
            .attr("stroke-width", 1.5);
        // Distal joint
        _torqarc = getJoinTorqueArcInfo(linkdetails.distal.angle, linkdetails.distal.torque);
        arcPath = describeArc(_lpshiftedpos[1][0], _lpshiftedpos[1][1], 20, _torqarc[0], _torqarc[1]);
        svglink2.append("path")
            .attr("d", arcPath)
            .attr("stroke", COMPCOLORS[1])
            .attr("fill", "none")
            .attr("stroke-width", 1.5);
    }

    // General arrow plotting function.
    function plotForceArrow(svg, start, force, color, linewidth=1.0, scale=0.025) {
        const end = [start[0] - force[0] * lengthToPixelScale * scale,
                     start[1] + force[1] * lengthToPixelScale * scale];
        // Don't draw the arrow if the force is too small
        if (math.norm(force) > 0.05) {
            // Define the arrow marker
            svg.append("defs").append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 0 10 10")
                .attr("refX", 9)
                .attr("refY", 5)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto-start-reverse")
                .append("path")
                .attr("d", "M 0 0 L 10 5 L 0 10 z")
                .attr("fill", color)
                .attr("stroke", color);

            // Draw the line with the arrow
            svg.append("line")
                .attr("x1", start[0])
                .attr("y1", start[1])
                .attr("x2", end[0])
                .attr("y2", end[1])
                .attr("fill", color)
                .attr("stroke", color)
                .attr("marker-end", "url(#arrow)")
                .attr("stroke-width", linewidth);
        }
    } 

    // Create the arm object once and reuse it
    const arm = new TwoLinkArm(
        [1, 1], // Initial lengths
        degreesToRadians([0, 0]) // Initial angles
    );

    // Attach event listeners to sliders
    ['l1', 'l2', 'theta1', 'theta2', 'torque1', 'torque2'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateArm);
    });

    // Initialize the arm visualization
    updateArm();
</script>
<footer>
    <p>Movement Science Club, Dept. of Bioengineering, CMC Vellore</p>
</footer>
</body>
</html>